"""Azure ACA Session tool spec."""

from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from io import BufferedReader, BytesIO
from typing import Callable, List, Optional, Any
from uuid import uuid4
import re
import os

from azure.identity import DefaultAzureCredential
from azure.core.credentials import AccessToken
import requests

from llama_index.core.tools.tool_spec.base import BaseToolSpec


@dataclass
class RemoteFileMetadata:
    """Metadata for a file in the session."""

    filename: str
    """The filename relative to `/mnt/data`."""

    size_in_bytes: int
    """The size of the file in bytes."""

    file_full_path: str
    """The full path of the file."""

    @staticmethod
    def from_dict(data: dict) -> "RemoteFileMetadata":
        """Create a RemoteFileMetadata object from a dictionary."""
        filename = data["filename"]
        return RemoteFileMetadata(
            filename=filename,
            size_in_bytes=data["size"],
            file_full_path=f"/mnt/data/{filename}"
        )


def _sanitize_input(query: str) -> str:
    """
    Sanitize input and remove whitespace,
    backtick & python (if llm mistakes python console as terminal)

    Args:
        query: The query to sanitize

    Returns:
        str: The sanitized query
    """

    # Removes `, whitespace & python from start
    query = re.sub(r"^(\s|`)*(?i:python)?\s*", "", query)
    # Removes whitespace & ` from end
    query = re.sub(r"(\s|`)*$", "", query)
    # Add new line if no new line was appended at the end of the query
    if not query.endswith("\n"):
        query += "\n"
    return query


class AzureACASessionToolSpec(BaseToolSpec):
    """Azure Container App Session tool spec."""

    spec_functions = ["code_interpreter", "list_files"]

    def __init__(
        self,
        pool_managment_endpoint: str,
        session_id: str = None,
    ) -> None:
        """Initialize with parameters."""
        self.pool_management_endpoint: str = pool_managment_endpoint

        def _access_token_provider_factory(self) -> Callable[[], Optional[str]]:
            self.access_token: AccessToken = None

            def access_token_provider(self) -> Optional[str]:
                """Create a function that returns an access token."""
                if self.access_token is None or datetime.fromtimestamp(self.access_token.expires_on, timezone.utc) > (datetime.now(timezone.utc) + timedelta(minutes=5)):
                    credential = DefaultAzureCredential()
                    self.access_token = credential.get_token("https://acasessions.io/.default")
                    return self.access_token.token

            return access_token_provider

        self.access_token_provider: Callable[[], Optional[str]] = _access_token_provider_factory(self)
        """A function that returns the access token to use for the session pool."""

        self.session_id: str = session_id
        """The session ID to use for the session pool. Defaults to a random UUID."""
        if self.session_id is None:
            self.session_id = str(uuid4())

        self.sanitize_input: bool = True
        """Whether to sanitize input before executing it."""

    def _build_url(self, path) -> str:
        pool_management_endpoint = self.pool_management_endpoint
        if not pool_management_endpoint:
            raise ValueError("pool_management_endpoint is not set")
        if not pool_management_endpoint.endswith("/"):
            pool_management_endpoint += "/"
        return pool_management_endpoint + path

    def code_interpreter(self, python_code: str):
        """
        This tool is used to execute python commands when you need to perform calculations or computations in Session Pool.
        Input should be a valid python command. The tool returns the result, stdout, and stderr.

        Args:
            python_code (str): Python code to be executed generated by llm.
        """

        def _run(self, python_code: str) -> Any:
            if self.sanitize_input:
                python_code = _sanitize_input(python_code)

            access_token = self.access_token_provider(self)
            api_url = self._build_url("python/execute")
            headers = {
                "Authorization": f"Bearer {access_token}",
                "Content-Type": "application/json",
            }
            body = {
                "properties": {
                    "identifier": self.session_id,
                    "codeInputType": "inline",
                    "executionType": "synchronous",
                    "pythonCode": python_code,
                }
            }

            response = requests.post(api_url, headers=headers, json=body)
            response.raise_for_status()
            response_json = response.json()

            return response_json

        return _run(self, python_code)

    def upload_file(self, data: BufferedReader = None, remote_file_path: str = None, local_file_path: str = None) -> List[RemoteFileMetadata]:
        """Upload a file to the session pool.

        Args:
            data: The data to upload.
            remote_file_path: The path to upload the file to, relative to `/mnt/data`. If local_file_path is provided, this is defaulted to its filename.
            local_file_path: The path to the local file to upload.

        Returns:
            List[RemoteFileMetadata]: The list of metadatas for the uploaded files.
        """

        if data and local_file_path:
            raise ValueError("data and local_file_path cannot be provided together")

        if local_file_path:
            if not remote_file_path:
                remote_file_path = os.path.basename(local_file_path)
            data = open(local_file_path, "rb")

        access_token = self.access_token_provider(self)
        api_url = self._build_url(f"python/uploadFile?identifier={self.session_id}")
        headers = {
            "Authorization": f"Bearer {access_token}",
        }
        payload = {}
        files = [
            ('file', (remote_file_path, data, 'application/octet-stream'))
        ]

        response = requests.request("POST", api_url, headers=headers, data=payload, files=files)
        response.raise_for_status()

        response_json = response.json()
        remote_files_metadatas = list()
        for entry in response_json["$values"]:
            remote_files_metadatas.append(RemoteFileMetadata.from_dict(entry))
        return remote_files_metadatas

    def download_file(self, *, remote_file_path: str, local_file_path: str = None) -> Optional[BufferedReader]:
        """Download a file from the session pool.

        Args:
            remote_file_path: The path to download the file from, relative to `/mnt/data`.
            local_file_path: The path to save the downloaded file to. If not provided, the file is returned as a BufferedReader.

        Returns:
            BufferedReader: The data of the downloaded file.
        """
        access_token = self.access_token_provider(self)
        api_url = self._build_url(f"python/downloadFile?identifier={self.session_id}&filename={remote_file_path}")
        headers = {
            "Authorization": f"Bearer {access_token}",
        }

        response = requests.get(api_url, headers=headers)
        response.raise_for_status()

        if local_file_path:
            with open(local_file_path, "wb") as f:
                f.write(response.content)
            return None

        return BytesIO(response.content)

    def list_files(self) -> list[RemoteFileMetadata]:
        """List the files in the session pool.

        Returns:
            list[RemoteFileMetadata]: The metadata for the files in the session pool
        """
        access_token = self.access_token_provider(self)
        api_url = self._build_url(f"python/files?identifier={self.session_id}")
        headers = {
            "Authorization": f"Bearer {access_token}",
        }

        response = requests.get(api_url, headers=headers)
        response.raise_for_status()

        response_json = response.json()
        return [RemoteFileMetadata.from_dict(entry) for entry in response_json["$values"]]
